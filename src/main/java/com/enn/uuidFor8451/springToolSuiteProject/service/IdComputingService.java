package com.enn.uuidFor8451.springToolSuiteProject.service;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;


public class IdComputingService {

	private final static AtomicLong rule2RunCounter = new AtomicLong();
	private final static AtomicLong rule3RunCounter = new AtomicLong();

    public static int initId() {
    	// return a random number between 1 and 1000
    	int random = (int)(Math.random() * 1000 + 1);
    	
    	return random;
         
    }
    
 // proc to find length of longest palindromic subsequence   
    public static int LPS(String s) {
    	int n = s.length();
    	int palindrome[][] = new int[n][n]; //Table to store lengths of palindrome subsequences.

		//Trivial case: single letter palindromes
		for (int i = 0; i < n; i++) {
		    	palindrome[i][i] = 1;
		}
		
		//Finding palindromes of length 2 to n and saving the longest
		for (int curr_len = 2; curr_len <= n; curr_len++) {
			for (int i = 0; i < n-curr_len+1; i++) {
				int j = i+curr_len-1;
				if (s.charAt(i) == s.charAt(j))//Trim if match and add 2  
				{
					palindrome[i][j] = palindrome[i+1][j-1] + 2; 
				}
				else //Trim one at a time and take max
				{
					palindrome[i][j] = Math.max(palindrome[i+1][j], palindrome[i][j-1]);
				}
			}
		}
	
		return palindrome[0][n-1];
    }    

    //   
    private static AtomicLong incrementRule2RunCounter() { 
         rule2RunCounter.getAndIncrement();
         return rule2RunCounter;         
    }

    private static AtomicLong incrementRule3RunCounter() { 
        rule3RunCounter.getAndIncrement();
        return rule3RunCounter;         
   }
    
    private static void initRuleRunCounters() { 
        rule2RunCounter.set(0);
        rule3RunCounter.set(0);
    }
    
    private static long generateNextNumber(long currentNumber, int x, int y) {
    	long nextNumber = currentNumber;
    	if (currentNumber % 2 == 0) {
            System.out.println("The number is even.");
        	incrementRule2RunCounter();    	
    		nextNumber = currentNumber / x;
    	}
         else {
            System.out.println("The number is odd.");
    		nextNumber = currentNumber+ y;
        	incrementRule3RunCounter();    	
         }
    	return nextNumber;
    }
    
    public static String generateUUID(int xParm, int yParm, int zParm) {
    	// do all logic here
    	/*
    	 You are being asked to simulate a UUID generator by creating sequences of
numbers, written out as strings. If the resulting string is under 30
characters long, it should padded, if it’s over 40 characters long – then
it should be truncated.

Please create a REST API with SpringBoot or Flask endpoint that implements a
function that generates these simulated sequences. Possible parameters of
x,y,z may be set with request.

Use this the rule for generating number sequences:

1.      start with a randomly generated (real) number

2.      If the number is even, then divide by x=2

3.      If the number is odd then add y=7

4.      Check for longest palindromic sub-sequence

5.      At least z=5 that #2 & #3 should run to generate sequence

6.      At least half of numbers should be generated by lines # 2 and #3  // ??Not sure about this requirement

    	 */

    	// initialize counters between requests
    	initRuleRunCounters();
    	
    	
    	//the sequence of various id numbers captured in a list    	
    	List<String> sequence = new ArrayList<String>();
    	
    	// these parms to be used to validate rules run count satisfy requirement (param "z")
    	boolean minRulesCountPassed = false;
    	boolean minRule2CountPerZParmPassed = false;
    	boolean minRule3CountPerZParmPassed = false;
    	
    	// initialize vars
    	long newUuId = 0;
    	String UUIDString = "";
    	long nextNumber = 0;   	
    	int newUuIdLen = 0;

    	// generate sequence in a loop
    	while (!minRulesCountPassed) {
    		// start with a random number
    		newUuId = initId();
    		
    		nextNumber =  generateNextNumber(newUuId, xParm, yParm);
    		// the uuid string is represented by "random number concatenated with next number found via rule"
    		UUIDString = (new Long(newUuId).toString()).trim() + (new Long(nextNumber).toString()).trim();
    		newUuId = Long.parseLong(UUIDString);
    		newUuIdLen = UUIDString.length();

    		// requirement says we check the lps.. here it is just outputting this for display in log
            System.out.println("Longest palindromic sub-sequence for uuid: '"+UUIDString+"' is => "+LPS(UUIDString));
            
            // Pad or truncate uuid    		
    		if (newUuIdLen <= 30) 
    			UUIDString = String.format("%40s", UUIDString); 
    		else if (newUuIdLen >40) 
    			UUIDString = UUIDString.substring(0, 39); 
    		
    		
    		minRule2CountPerZParmPassed = (rule2RunCounter.intValue() >= zParm);
    		minRule3CountPerZParmPassed = (rule3RunCounter.intValue() >= zParm);
    		    		
    		minRulesCountPassed = minRule2CountPerZParmPassed && minRule3CountPerZParmPassed;
    		sequence.add(UUIDString);
    	}
    	
    	return sequence.toString();
    	
    
    }
}
